# 2.6.3 VSCode插件开发WebView


### 3.1. 创建WebView

```
context.subscriptions.push(vscode.commands.registerCommand('extension.demo.openWebview', function (uri) {
	// 创建webview
	const panel = vscode.window.createWebviewPanel(
		'testWebview', // viewType
		"WebView演示", // 视图标题
		vscode.ViewColumn.One, // 显示在编辑器的哪个部位
		{
			enableScripts: true, // 启用JS，默认禁用
			retainContextWhenHidden: true, // webview被隐藏时保持状态，避免被重置
		}
	);
	panel.webview.html = `<html><body>你好，我是Webview</body></html>`
```
>
- 默认情况下，在Web视图中禁用JavaScript，但可以通过传入`enableScripts: true`选项轻松启用；
- 默认情况下当webview被隐藏时资源会被销毁，通过`retainContextWhenHidden: true`会一直保存，但会占用较大内存开销，仅在需要时开启；



### 3.2. 加载本地资源
>出于安全考虑，Webview默认无法直接访问本地资源，它在一个孤立的上下文中运行，想要加载本地图片、js、css等必须通过特殊的vscode-resource:协议，网页里面所有的静态资源都要转换成这种格式，否则无法被正常加载。

>`vscode-resource:`协议类似于`file:`协议，但它只允许访问特定的本地文件。和`file:`一样，`vscode-resource:`从磁盘加载绝对路径的资源。

封装了一个转换方法：
```
/**
 * 获取某个扩展文件相对于webview需要的一种特殊路径格式
 * 形如：vscode-resource:/Users/toonces/projects/vscode-cat-coding/media/cat.gif
 * @param context 上下文
 * @param relativePath 扩展中某个文件相对于根目录的路径，如 images/test.jpg
 */
getExtensionFileVscodeResource: function(context, relativePath) {
	const diskPath = vscode.Uri.file(path.join(context.extensionPath, relativePath));
	return diskPath.with({ scheme: 'vscode-resource' }).toString();
}
```
默认情况下，vscode-resource:只能访问以下位置中的资源：

- 扩展程序安装目录中的文件。
- 用户当前活动的工作区内。
- 当然，你还可以使用dataURI直接在Webview中嵌入资源，这种方式没有限制；


### 3.3. 从文件加载HTML内容
默认不支持从文件加载HTML，需要自己封装代码,简单封装了一个供大家参考：

```
/**
 * 从某个HTML文件读取能被Webview加载的HTML内容
 * @param {*} context 上下文
 * @param {*} templatePath 相对于插件根目录的html文件相对路径
 */
function getWebViewContent(context, templatePath) {
	const resourcePath = path.join(context.extensionPath, templatePath);
	const dirPath = path.dirname(resourcePath);
	let html = fs.readFileSync(resourcePath, 'utf-8');
	// vscode不支持直接加载本地资源，需要替换成其专有路径格式，这里只是简单的将样式和JS的路径替换
	html = html.replace(/(<link.+?href="|<script.+?src="|<img.+?src=")(.+?)"/g, (m, $1, $2) => {
		return $1 + vscode.Uri.file(path.resolve(dirPath, $2)).with({ scheme: 'vscode-resource' }).toString() + '"';
	});
	return html;
}
```
>运行这段代码之后，会自动将HTML文件中link、href、script、img的资源相对路径全部替换成正确的vscode-resource:绝对路径，例如：
```
../../lib/vue-2.5.17/vue.js
变成
vscode-resource:/Users/test/workspace/vscode-plugin-demo/lib/vue-2.5.17/vue.js
```

使用方法如下：

```
panel.webview.html = getWebViewContent(context, 'src/view/test-webview.html');
```

## 3.4. 消息通信
>Webview和普通网页非常类似，不能直接调用任何VSCodeAPI，但是，
它唯一特别之处就在于多了一个名叫acquireVsCodeApi的方法，执行这个方法会返回一个超级阉割版的vscode对象，
这个对象里面有且仅有如下3个可以和插件通信的API：

插件和Webview之间如何互相通信呢？

- 插件给Webview发送消息（支持发送任意可以被JSON化的数据）：
```
panel.webview.postMessage({text: '你好，我是小茗同学！'});
```

- Webview端接收：
```
window.addEventListener('message', event => {
	const message = event.data;
	console.log('Webview接收到的消息：', message);
}
```

---------------

- Webview主动发送消息给插件：
```
vscode.postMessage({text: '你好，我是Webview啊！'});
```

- 插件接收：

```
panel.webview.onDidReceiveMessage(message => {
	console.log('插件收到的消息：', message);
}, undefined, context.subscriptions);
```

### 3.4.1. 简单通信封装
为了双方通信方便，我把它们简单封装了一下，仅供参考，Webview端：

```
const callbacks = {}; // 存放所有的回调函数
/**
 * 调用vscode原生api
 * @param data 可以是类似 {cmd: 'xxx', param1: 'xxx'}，也可以直接是 cmd 字符串
 * @param cb 可选的回调函数
 */
function callVscode(data, cb) {
	if (typeof data === 'string') {
		data = { cmd: data };
	}
	if (cb) {
		// 时间戳加上5位随机数
		const cbid = Date.now() + '' + Math.round(Math.random() * 100000);
		// 将回调函数分配一个随机cbid然后存起来，后续需要执行的时候再捞起来
		callbacks[cbid] = cb;
		data.cbid = cbid;
	}
	vscode.postMessage(data);
}
window.addEventListener('message', event => {
	const message = event.data;
	switch (message.cmd) {
		// 来自vscode的回调
		case 'vscodeCallback':
			console.log(message.data);
			(callbacks[message.cbid] || function () { })(message.data);
			delete callbacks[message.cbid]; // 执行完回调删除
			break;
		default: break;
	}
});
```

插件端：
```
let global = { projectPath, panel};
panel.webview.onDidReceiveMessage(message => {
	if (messageHandler[message.cmd]) {
		// cmd表示要执行的方法名称
		messageHandler[message.cmd](global, message);
	} else {
		util.showError(`未找到名为 ${message.cmd} 的方法!`);
	}
}, undefined, context.subscriptions);

/**
 * 存放所有消息回调函数，根据 message.cmd 来决定调用哪个方法，
 * 想调用什么方法，就在这里写一个和cmd同名的方法实现即可
 */
const messageHandler = {
	// 弹出提示
	alert(global, message) {
		util.showInfo(message.info);
	},
	// 显示错误提示
	error(global, message) {
		util.showError(message.info);
	},
	// 回调示例：获取工程名
	getProjectName(global, message) {
		invokeCallback(global.panel, message, util.getProjectName(global.projectPath));
	}
}
/**
 * 执行回调函数
 * @param {*} panel 
 * @param {*} message 
 * @param {*} resp 
 */
function invokeCallback(panel, message, resp) {
	console.log('回调消息：', resp);
	// 错误码在400-600之间的，默认弹出错误提示
	if (typeof resp == 'object' && resp.code && resp.code >= 400 && resp.code < 600) {
		util.showError(resp.message || '发生未知错误！');
	}
	panel.webview.postMessage({cmd: 'vscodeCallback', cbid: message.cbid, data: resp});
}
```

按上述方法封装之后，例如，Webview端想要执行名为openFileInVscode命令只需要这样：

```
callVscode({cmd: 'openFileInVscode', path: `package.json`}, (message) => {
	this.alert(message);
});
```

然后在插件端的messageHandler实现openFileInVscode方法即可，其它都不用管：

```
const messageHandler = {
	// 省略其它方法
	openFileInVscode(global, message) {
		util.openFileInVscode(`${global.projectPath}/${message.path}`);
		invokeCallback(global.panel, message, '打开文件成功！');
	}
};
```

以上封装的比较随便，只是给大家提供一个思路


## 参考
- [extensions/webview](https://code.visualstudio.com/docs/extensions/webview)
- [VSCode插件开发全攻略（七）WebView](http://blog.haoji.me/vscode-plugin-webview.html)
